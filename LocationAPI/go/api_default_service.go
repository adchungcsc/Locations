/*
 * Location API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"log"
	"os"
	"strconv"
)

// DefaultApiService is a service that implements the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API. 
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	return &DefaultApiService{}
}

//var databaseConnection *pgx.Conn

var databaseConnection *pgxpool.Pool

func databaseConnect() {
	connStr := os.Getenv("connectionString")
	config, err := pgxpool.ParseConfig(connStr)
	if err != nil {
		log.Fatal("error configuring the database: ", err)
	}
	config.AfterConnect = func(ctx context.Context, conn *pgx.Conn) error {
		//no need to do anything with a new connection added to the pool.
		return nil
	}

	databaseConnection, err = pgxpool.ConnectConfig(context.Background(), config)
}

// FindAllLocations - Get all locations
func (s *DefaultApiService) FindAllLocations() ([]Location, error) {
	rows, err := databaseConnection.Query(context.Background(), "SELECT * FROM Locations;")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	var locations []Location
	var counter = 0
	fmt.Println("READING FROM DB")

	for rows.Next() {
		var locationId int
		var locationName, description string
		var latitude, longitude float32
		if err := rows.Scan(&locationId, &locationName, &description, &latitude, &longitude); err != nil {
			log.Fatal(err)
		}
		fmt.Println("READ " + strconv.Itoa(locationId) + " " + strconv.FormatFloat(float64(latitude), 'f', 5, 64) + " " + strconv.FormatFloat(float64(longitude), 'f', 5, 64) + " " + locationName + " " + description)

		location := Location{
			LocationName: locationName,
			Latitude:     latitude,
			Longitude:    longitude,
			Description:  description,
		}
		locations = append(locations, location)
		counter++
	}

	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.
	return locations, err
}

// FindLocation - Find a location
func (s *DefaultApiService) FindLocation(locationName string) ([]Location, error) {
	rows, err := databaseConnection.Query(context.Background(), "SELECT * FROM Locations WHERE locationName = $1", locationName)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	var locations []Location
	var counter = 0
	fmt.Println("READING FROM DB")

	for rows.Next() {
		var locationId int
		var locationName, description string
		var latitude, longitude float32
		if err := rows.Scan(&locationId, &locationName, &description, &latitude, &longitude); err != nil {
			log.Fatal(err)
		}
		fmt.Println("READ " + strconv.Itoa(locationId) + " " + strconv.FormatFloat(float64(latitude), 'f', 5, 64) + " " + strconv.FormatFloat(float64(longitude), 'f', 5, 64) + " " + locationName + " " + description)

		location := Location{
			LocationName: locationName,
			Latitude:     latitude,
			Longitude:    longitude,
			Description:  description,
		}
		locations = append(locations, location)
		counter++
	}
	return locations, err
}

// DeleteLocation - Delete a location
func (s *DefaultApiService) DeleteLocation(locationName string) (Location, error) {
	_, err := databaseConnection.Query(context.Background(), "DELETE FROM Locations WHERE locationName = $1", locationName)
	if err != nil {
		log.Fatal(err)
	}

	return Location{
		LocationName: locationName,
	}, err
}

// InsertLocation - Insert a new location
func (s *DefaultApiService) InsertLocation(locationName string, latitude float32, longitude float32, description string) (Location, error) {
	_, err := databaseConnection.Exec(context.Background(), "INSERT INTO Locations (locationName, latitude, longitude, description) VALUES ($1, $2, $3, $4)", locationName, latitude, longitude, description)
	if err != nil {
		log.Fatal(err)
	}
	location := Location{
		LocationName: locationName,
		Latitude:     latitude,
		Longitude:    longitude,
		Description:  description,
	}
	return location, err
}

// UpdateLocation - Update an existing location
func (s *DefaultApiService) UpdateLocation(locationName string, description string) (Location, error) {
	_, err := databaseConnection.Exec(context.Background(), "UPDATE Locations SET description = $1 WHERE locationName = $2", description, locationName)
	if err != nil {
		log.Fatal(err)
	}

	return Location{
		LocationName: locationName,
		Description:  description,
	}, err
}

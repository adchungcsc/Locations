/*
 * Location API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v4"
	"log"
	"strconv"
)

// DefaultApiService is a service that implements the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API. 
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	return &DefaultApiService{}
}

//func databaseConnect(){
//	if dbConnection != nil {
//		return
//	}
//	//TODO: un-hard code this and read in connString from a file.
//	config, err := pgx.ParseConfig("postgresql://maxroach@localhost:26257/defaultdb?sslmode=disable")
//	if err != nil {
//		log.Fatal("error configuring the database: ", err)
//	}
//
//	// Connect to the "bank" database.
//	dbConnection, err := pgx.ConnectConfig(context.Background(), config)
//	if err != nil {
//		log.Fatal("error connecting to the database: ", err)
//	}
//	defer dbConnection.Close(context.Background())
//}

// DeleteLocation - Delete a location
func (s *DefaultApiService) DeleteLocation(locationName string) (Location, error) {
	var dbConnection *pgx.Conn
	//TODO: un-hard code this and read in connString from a file (user is also only on my local test DB and not running on a prod DB).
	config, err := pgx.ParseConfig("postgresql://maxroach@localhost:26257/defaultdb?sslmode=disable")
	if err != nil {
		log.Fatal("error configuring the database: ", err)
	}

	dbConnection, err = pgx.ConnectConfig(context.Background(), config)
	if err != nil {
		log.Fatal("error connecting to the database: ", err)
	}
	defer dbConnection.Close(context.Background())

	_, err = dbConnection.Query(context.Background(), "DELETE FROM Locations WHERE locationName = $1", locationName)
	if err != nil {
		log.Fatal(err)
	}

	return Location{
		LocationName: locationName,
	}, err
}

// FindAllLocations - Get all locations
func (s *DefaultApiService) FindAllLocations() ([]Location, error) {
	var dbConnection *pgx.Conn
	//TODO: un-hard code this and read in connString from a file (user is also only on my local test DB and not running on a prod DB).
	config, err := pgx.ParseConfig("postgresql://maxroach@localhost:26257/defaultdb?sslmode=disable")
	if err != nil {
		log.Fatal("error configuring the database: ", err)
	}

	dbConnection, err = pgx.ConnectConfig(context.Background(), config)
	if err != nil {
		log.Fatal("error connecting to the database: ", err)
	}
	defer dbConnection.Close(context.Background())

	rows, err := dbConnection.Query(context.Background(), "SELECT * FROM Locations")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	var locations []Location
	var counter = 0
	fmt.Println("READING FROM DB")

	for rows.Next() {
		var locationId int
		var locationName, description string
		var latitude, longitude float32
		if err := rows.Scan(&locationId, &locationName, &description, &latitude, &longitude); err != nil {
			log.Fatal(err)
		}
		fmt.Println("READ " + strconv.Itoa(locationId) + " " + strconv.FormatFloat(float64(latitude), 'f', 5, 64) + " " + strconv.FormatFloat(float64(longitude), 'f', 5, 64) + " " + locationName + " " + description)

		location := Location{
			LocationName: locationName,
			Latitude:     latitude,
			Longitude:    longitude,
			Description:  description,
		}
		locations = append(locations, location)
		counter++
	}

	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.
	return locations, err
}

// FindLocation - Find a location
func (s *DefaultApiService) FindLocation(locationName string) ([]Location, error) {
	var dbConnection *pgx.Conn
	//TODO: un-hard code this and read in connString from a file (user is also only on my local test DB and not running on a prod DB).
	config, err := pgx.ParseConfig("postgresql://maxroach@localhost:26257/defaultdb?sslmode=disable")
	if err != nil {
		log.Fatal("error configuring the database: ", err)
	}

	dbConnection, err = pgx.ConnectConfig(context.Background(), config)
	if err != nil {
		log.Fatal("error connecting to the database: ", err)
	}
	defer dbConnection.Close(context.Background())

	rows, err := dbConnection.Query(context.Background(), "SELECT * FROM Locations WHERE locationName = $1", locationName)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	var locations []Location
	var counter = 0
	fmt.Println("READING FROM DB")

	for rows.Next() {
		var locationId int
		var locationName, description string
		var latitude, longitude float32
		if err := rows.Scan(&locationId, &locationName, &description, &latitude, &longitude); err != nil {
			log.Fatal(err)
		}
		fmt.Println("READ " + strconv.Itoa(locationId) + " " + strconv.FormatFloat(float64(latitude), 'f', 5, 64) + " " + strconv.FormatFloat(float64(longitude), 'f', 5, 64) + " " + locationName + " " + description)

		location := Location{
			LocationName: locationName,
			Latitude:     latitude,
			Longitude:    longitude,
			Description:  description,
		}
		locations = append(locations, location)
		counter++
	}
	return locations, err
}

// InsertLocation - Insert a new location
func (s *DefaultApiService) InsertLocation(locationName string, latitude float32, longitude float32, description string) (Location, error) {
	//TODO: cleanup database conn code and simplify instead of reconnecting everytime
	var dbConnection *pgx.Conn
	config, err := pgx.ParseConfig("postgresql://maxroach@localhost:26257/defaultdb?sslmode=disable")
	if err != nil {
		log.Fatal("error configuring the database: ", err)
	}

	dbConnection, err = pgx.ConnectConfig(context.Background(), config)
	if err != nil {
		log.Fatal("error connecting to the database: ", err)
	}
	defer dbConnection.Close(context.Background())

	_, err = dbConnection.Exec(context.Background(), "INSERT INTO Locations (locationName, latitude, longitude, description) VALUES ($1, $2, $3, $4)", locationName, latitude, longitude, description)
	if err != nil {
		log.Fatal(err)
	}
	location := Location{
		LocationName: locationName,
		Latitude:     latitude,
		Longitude:    longitude,
		Description:  description,
	}
	return location, err
}

// UpdateLocation - Update an existing location
func (s *DefaultApiService) UpdateLocation(locationName string, description string) (Location, error) {
	var dbConnection *pgx.Conn
	//TODO: un-hard code this and read in connString from a file (user is also only on my local test DB and not running on a prod DB).
	config, err := pgx.ParseConfig("postgresql://maxroach@localhost:26257/defaultdb?sslmode=disable")
	if err != nil {
		log.Fatal("error configuring the database: ", err)
	}

	dbConnection, err = pgx.ConnectConfig(context.Background(), config)
	if err != nil {
		log.Fatal("error connecting to the database: ", err)
	}
	defer dbConnection.Close(context.Background())

	_, err = dbConnection.Query(context.Background(), "UPDATE Locations SET description = $1 WHERE locationName = $2", description, locationName)
	if err != nil {
		log.Fatal(err)
	}

	return Location{
		LocationName: locationName,
		Description:  description,
	}, err
}
